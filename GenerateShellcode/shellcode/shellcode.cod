; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	HashROR13A
PUBLIC	PEGetProcAddressH
PUBLIC	UserShellInitializeFunctions
PUBLIC	hookcode
;	COMDAT pdata
pdata	SEGMENT
$pdata$PEGetProcAddressH DD imagerel $LN23
	DD	imagerel $LN23+142
	DD	imagerel $unwind$PEGetProcAddressH
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$UserShellInitializeFunctions DD imagerel $LN4
	DD	imagerel $LN4+315
	DD	imagerel $unwind$UserShellInitializeFunctions
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$hookcode DD imagerel $LN5
	DD	imagerel $LN5+229
	DD	imagerel $unwind$hookcode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$hookcode DD 091e01H
	DD	04f741eH
	DD	04d641eH
	DD	04c341eH
	DD	04a011eH
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$UserShellInitializeFunctions DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PEGetProcAddressH DD 060f01H
	DD	03740fH
	DD	02640aH
	DD	013405H
xdata	ENDS
; Function compile flags: /Ogspy
; File c:\users\killvxk\desktop\ÁÙÊ±\generateshellcode\shellcode\shellcode.c
;	COMDAT hookcode
_TEXT	SEGMENT
szFile$ = 64
arg1$ = 608
lpBaseKernel32$ = 616
dwWrite$1 = 624
hookcode PROC						; COMDAT

; 199  : {

$LN5:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0000b	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  0000f	55		 push	 rbp
  00010	48 8d a8 a8 fe
	ff ff		 lea	 rbp, QWORD PTR [rax-344]
  00017	48 81 ec 50 02
	00 00		 sub	 rsp, 592		; 00000250H
  0001e	48 8b da	 mov	 rbx, rdx

; 200  :     //arg1æ˜¯r9,  r8, rdx, rcx, rspï¼Œæ­¤å†…å®¹ä¸Žmy_hookå¼€å¤´pushçš„å‡½æ•°æœ‰å…³ã€‚
; 201  :     UNREFERENCED_PARAMETER(arg1);
; 202  : 	HLOCAL(WINAPI*fnLocalAlloc)(UINT, SIZE_T);
; 203  : 	PUSERSHELL_FUNCTIONS funSets;       //shellcodeéœ€è¦å‡½æ•°çš„é›†åˆçš„ç»“æž„ä½“
; 204  : 	fnLocalAlloc = PEGetProcAddressH((HMODULE)lpBaseKernel32, H_LocalAlloc);//èŽ·å¾—LocalAllocåœ°å€

  00021	ba fa 97 02 4c	 mov	 edx, 1275238394		; 4c0297faH
  00026	48 8b cb	 mov	 rcx, rbx
  00029	e8 00 00 00 00	 call	 PEGetProcAddressH

; 205  : 	funSets = (PUSERSHELL_FUNCTIONS)fnLocalAlloc(LMEM_ZEROINIT, sizeof(USERSHELL_FUNCTIONS));

  0002e	ba 88 00 00 00	 mov	 edx, 136		; 00000088H
  00033	8d 4a b8	 lea	 ecx, QWORD PTR [rdx-72]
  00036	ff d0		 call	 rax

; 206  : 	UserShellInitializeFunctions((HMODULE)lpBaseKernel32, funSets);

  00038	48 8b d0	 mov	 rdx, rax
  0003b	48 8b cb	 mov	 rcx, rbx
  0003e	48 8b f8	 mov	 rdi, rax
  00041	e8 00 00 00 00	 call	 UserShellInitializeFunctions

; 207  : 
; 208  : 	//ä¸‹é¢åªæ˜¯shellcodeçš„ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹
; 209  :     HANDLE hFile;
; 210  :     WCHAR szFile[MAX_PATH];
; 211  : 	szFile[0] = L'e';
; 212  : 	szFile[1] = L':';
; 213  : 	szFile[2] = L'\\';
; 214  : 	szFile[3] = L'S';
; 215  : 	szFile[4] = L'.';
; 216  : 	szFile[5] = L't';
; 217  : 	szFile[6] = L'x';
; 218  : 	szFile[7] = L't';
; 219  : 	szFile[8] = L'\0';

  00046	33 f6		 xor	 esi, esi
  00048	c7 44 24 40 65
	00 3a 00	 mov	 DWORD PTR szFile$[rsp], 3801189 ; 003a0065H
  00050	66 89 74 24 50	 mov	 WORD PTR szFile$[rsp+16], si
  00055	c7 44 24 44 5c
	00 53 00	 mov	 DWORD PTR szFile$[rsp+4], 5439580 ; 0053005cH
  0005d	c7 44 24 48 2e
	00 74 00	 mov	 DWORD PTR szFile$[rsp+8], 7602222 ; 0074002eH
  00065	c7 44 24 4c 78
	00 74 00	 mov	 DWORD PTR szFile$[rsp+12], 7602296 ; 00740078H

; 220  : 	if (funSets->CreateFileW)

  0006d	48 8b 87 80 00
	00 00		 mov	 rax, QWORD PTR [rdi+128]
  00074	48 85 c0	 test	 rax, rax
  00077	74 53		 je	 SHORT $LN2@hookcode

; 221  : 	{
; 222  : 		DWORD dwWrite;
; 223  : 		dwWrite = 0;
; 224  : 		hFile = funSets->CreateFileW(szFile, GENERIC_ALL, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

  00079	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0007e	44 8d 46 01	 lea	 r8d, QWORD PTR [rsi+1]
  00082	c7 44 24 28 80
	00 00 00	 mov	 DWORD PTR [rsp+40], 128	; 00000080H
  0008a	48 8d 4c 24 40	 lea	 rcx, QWORD PTR szFile$[rsp]
  0008f	45 33 c9	 xor	 r9d, r9d
  00092	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0009a	ba 00 00 00 10	 mov	 edx, 268435456		; 10000000H
  0009f	89 b5 70 01 00
	00		 mov	 DWORD PTR dwWrite$1[rbp-256], esi
  000a5	ff d0		 call	 rax

; 225  : 		funSets->WriteFile(hFile, szFile, sizeof(szFile), &dwWrite, NULL);

  000a7	4c 8d 8d 70 01
	00 00		 lea	 r9, QWORD PTR dwWrite$1[rbp-256]
  000ae	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  000b3	41 b8 08 02 00
	00		 mov	 r8d, 520		; 00000208H
  000b9	48 8d 54 24 40	 lea	 rdx, QWORD PTR szFile$[rsp]
  000be	48 8b c8	 mov	 rcx, rax
  000c1	48 8b d8	 mov	 rbx, rax
  000c4	ff 57 50	 call	 QWORD PTR [rdi+80]

; 226  : 		funSets->CloseHandle(hFile);

  000c7	48 8b cb	 mov	 rcx, rbx
  000ca	ff 17		 call	 QWORD PTR [rdi]
$LN2@hookcode:

; 227  : 	}
; 228  : 
; 229  :     /*å¦‚æžœä½ ä½¿ç”¨äº†hookï¼Œ
; 230  :       åˆ™è¦è°ƒç”¨åŽŸå§‹å‡½æ•°ä¹Ÿå°±æ˜¯entry.asmä¸­çš„jmp_old_hook
; 231  : 	  å®šä¹‰fnç±»åž‹ï¼Œç„¶åŽå¼ºåˆ¶è½¬åŒ–è°ƒç”¨å°±è¡Œäº†,å¦‚*/
; 232  : 
; 233  : 	//VOID(WINAPI*ff)(UINT);
; 234  : 	//ff = jmp_old_hook;
; 235  : 	//ff(999);
; 236  : }

  000cc	4c 8d 9c 24 50
	02 00 00	 lea	 r11, QWORD PTR [rsp+592]
  000d4	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  000d8	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  000dc	49 8b 7b 28	 mov	 rdi, QWORD PTR [r11+40]
  000e0	49 8b e3	 mov	 rsp, r11
  000e3	5d		 pop	 rbp
  000e4	c3		 ret	 0
hookcode ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\killvxk\desktop\ÁÙÊ±\generateshellcode\shellcode\shellcode.c
;	COMDAT UserShellInitializeFunctions
_TEXT	SEGMENT
hModuleKernel32$ = 48
fnu$ = 56
UserShellInitializeFunctions PROC			; COMDAT

; 172  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 173  : 
; 174  : 	fnu->CloseHandle = PEGetProcAddressH(hModuleKernel32, H_CloseHandle);

  00010	ba fb 97 fd 0f	 mov	 edx, 268277755		; 0ffd97fbH
  00015	e8 00 00 00 00	 call	 PEGetProcAddressH

; 175  : 	fnu->CreatePipe = PEGetProcAddressH(hModuleKernel32, H_CreatePipe);

  0001a	ba 80 8f 0c 17	 mov	 edx, 386699136		; 170c8f80H
  0001f	48 89 07	 mov	 QWORD PTR [rdi], rax
  00022	48 8b cb	 mov	 rcx, rbx
  00025	e8 00 00 00 00	 call	 PEGetProcAddressH

; 176  : 	fnu->CreateProcessA = PEGetProcAddressH(hModuleKernel32, H_CreateProcessA);

  0002a	ba 72 fe b3 16	 mov	 edx, 380894834		; 16b3fe72H
  0002f	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax
  00033	48 8b cb	 mov	 rcx, rbx
  00036	e8 00 00 00 00	 call	 PEGetProcAddressH

; 177  : 	fnu->CreateThread = PEGetProcAddressH(hModuleKernel32, H_CreateThread);

  0003b	ba 6b d0 2b ca	 mov	 edx, -903098261		; ca2bd06bH
  00040	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax
  00044	48 8b cb	 mov	 rcx, rbx
  00047	e8 00 00 00 00	 call	 PEGetProcAddressH

; 178  : 	fnu->GetExitCodeProcess = PEGetProcAddressH(hModuleKernel32, H_GetExitCodeProcess);

  0004c	ba 74 ab 30 ac	 mov	 edx, -1406096524	; ac30ab74H
  00051	48 89 47 18	 mov	 QWORD PTR [rdi+24], rax
  00055	48 8b cb	 mov	 rcx, rbx
  00058	e8 00 00 00 00	 call	 PEGetProcAddressH

; 179  : 	fnu->GetLastError = PEGetProcAddressH(hModuleKernel32, H_GetLastError);

  0005d	ba 66 19 da 75	 mov	 edx, 1977227622		; 75da1966H
  00062	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  00066	48 8b cb	 mov	 rcx, rbx
  00069	e8 00 00 00 00	 call	 PEGetProcAddressH

; 180  : 	fnu->LocalAlloc = PEGetProcAddressH(hModuleKernel32, H_LocalAlloc);

  0006e	ba fa 97 02 4c	 mov	 edx, 1275238394		; 4c0297faH
  00073	48 89 47 28	 mov	 QWORD PTR [rdi+40], rax
  00077	48 8b cb	 mov	 rcx, rbx
  0007a	e8 00 00 00 00	 call	 PEGetProcAddressH

; 181  : 	fnu->LocalFree = PEGetProcAddressH(hModuleKernel32, H_LocalFree);

  0007f	ba f6 ea ba 5c	 mov	 edx, 1555753718		; 5cbaeaf6H
  00084	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax
  00088	48 8b cb	 mov	 rcx, rbx
  0008b	e8 00 00 00 00	 call	 PEGetProcAddressH

; 182  : 	fnu->ReadFile = PEGetProcAddressH(hModuleKernel32, H_ReadFile);

  00090	ba 16 65 fa 10	 mov	 edx, 284845334		; 10fa6516H
  00095	48 89 47 38	 mov	 QWORD PTR [rdi+56], rax
  00099	48 8b cb	 mov	 rcx, rbx
  0009c	e8 00 00 00 00	 call	 PEGetProcAddressH

; 183  : 	fnu->Sleep = PEGetProcAddressH(hModuleKernel32, H_Sleep);

  000a1	ba b0 49 2d db	 mov	 edx, -617789008		; db2d49b0H
  000a6	48 89 47 40	 mov	 QWORD PTR [rdi+64], rax
  000aa	48 8b cb	 mov	 rcx, rbx
  000ad	e8 00 00 00 00	 call	 PEGetProcAddressH

; 184  : 	fnu->WriteFile = PEGetProcAddressH(hModuleKernel32, H_WriteFile);

  000b2	ba 1f 79 0a e8	 mov	 edx, -401966817		; e80a791fH
  000b7	48 89 47 48	 mov	 QWORD PTR [rdi+72], rax
  000bb	48 8b cb	 mov	 rcx, rbx
  000be	e8 00 00 00 00	 call	 PEGetProcAddressH

; 185  : 	fnu->GetModuleHandleA = PEGetProcAddressH(hModuleKernel32, H_GetModuleHandleA);

  000c3	ba 04 49 32 d3	 mov	 edx, -751679228		; d3324904H
  000c8	48 89 47 50	 mov	 QWORD PTR [rdi+80], rax
  000cc	48 8b cb	 mov	 rcx, rbx
  000cf	e8 00 00 00 00	 call	 PEGetProcAddressH

; 186  : 	fnu->GetProcAddress = PEGetProcAddressH(hModuleKernel32, H_GetProcAddress);

  000d4	ba aa fc 0d 7c	 mov	 edx, 2081291434		; 7c0dfcaaH
  000d9	48 89 47 60	 mov	 QWORD PTR [rdi+96], rax
  000dd	48 8b cb	 mov	 rcx, rbx
  000e0	e8 00 00 00 00	 call	 PEGetProcAddressH

; 187  : 	fnu->VirtualAlloc = PEGetProcAddressH(hModuleKernel32, H_VirtualAlloc);

  000e5	ba 54 ca af 91	 mov	 edx, -1850750380	; 91afca54H
  000ea	48 89 47 58	 mov	 QWORD PTR [rdi+88], rax
  000ee	48 8b cb	 mov	 rcx, rbx
  000f1	e8 00 00 00 00	 call	 PEGetProcAddressH

; 188  : 	fnu->VirtualProtect = PEGetProcAddressH(hModuleKernel32, H_VirtualProtect);

  000f6	ba 1b c6 46 79	 mov	 edx, 2034681371		; 7946c61bH
  000fb	48 89 47 68	 mov	 QWORD PTR [rdi+104], rax
  000ff	48 8b cb	 mov	 rcx, rbx
  00102	e8 00 00 00 00	 call	 PEGetProcAddressH

; 189  : 	fnu->VirtualFree = PEGetProcAddressH(hModuleKernel32, H_VirtualFree);

  00107	ba ac 33 06 03	 mov	 edx, 50738092		; 030633acH
  0010c	48 89 47 70	 mov	 QWORD PTR [rdi+112], rax
  00110	48 8b cb	 mov	 rcx, rbx
  00113	e8 00 00 00 00	 call	 PEGetProcAddressH

; 190  : 	fnu->CreateFileW = PEGetProcAddressH(hModuleKernel32, H_CreateFileW);

  00118	ba bb 17 00 7c	 mov	 edx, 2080380859		; 7c0017bbH
  0011d	48 89 47 78	 mov	 QWORD PTR [rdi+120], rax
  00121	48 8b cb	 mov	 rcx, rbx
  00124	e8 00 00 00 00	 call	 PEGetProcAddressH

; 191  : }

  00129	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0012e	48 89 87 80 00
	00 00		 mov	 QWORD PTR [rdi+128], rax
  00135	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00139	5f		 pop	 rdi
  0013a	c3		 ret	 0
UserShellInitializeFunctions ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\killvxk\desktop\ÁÙÊ±\generateshellcode\shellcode\shellcode.c
;	COMDAT PEGetProcAddressH
_TEXT	SEGMENT
hModuleIn$ = 8
dwProcNameH$ = 16
PEGetProcAddressH PROC					; COMDAT

; 148  : {

$LN23:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi

; 149  : 	ULONG_PTR hModule = (ULONG_PTR)hModuleIn;
; 150  : 	PDWORD pdwRVAAddrNames, pdwRVAAddrFunctions;
; 151  : 	PWORD pwNameOrdinals;
; 152  : 	DWORD i, dwFnIdx, dwHash;
; 153  : 	LPSTR sz;
; 154  : 	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)hModule; // dos header.
; 155  : 	PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)(hModule + dosHeader->e_lfanew); // nt header

  0000f	48 63 41 3c	 movsxd	 rax, DWORD PTR [rcx+60]
  00013	4c 8b c9	 mov	 r9, rcx
  00016	8b f2		 mov	 esi, edx

; 156  : 	PIMAGE_EXPORT_DIRECTORY exp = (PIMAGE_EXPORT_DIRECTORY)(ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + hModule);

  00018	44 8b 84 08 88
	00 00 00	 mov	 r8d, DWORD PTR [rax+rcx+136]
  00020	4c 03 c1	 add	 r8, rcx

; 157  : 	pdwRVAAddrNames = (PDWORD)(hModule + exp->AddressOfNames);

  00023	45 8b 50 20	 mov	 r10d, DWORD PTR [r8+32]

; 158  : 	pwNameOrdinals = (PWORD)(hModule + exp->AddressOfNameOrdinals);

  00027	45 8b 58 24	 mov	 r11d, DWORD PTR [r8+36]
  0002b	4c 03 d1	 add	 r10, rcx

; 159  : 	pdwRVAAddrFunctions = (PDWORD)(hModule + exp->AddressOfFunctions);

  0002e	41 8b 58 1c	 mov	 ebx, DWORD PTR [r8+28]
  00032	4c 03 d9	 add	 r11, rcx
  00035	41 8b 78 18	 mov	 edi, DWORD PTR [r8+24]
  00039	48 03 d9	 add	 rbx, rcx

; 160  : 	for(i = 0; i < exp->NumberOfNames; i++) {

  0003c	33 c9		 xor	 ecx, ecx
  0003e	85 ff		 test	 edi, edi
  00040	74 2d		 je	 SHORT $LN3@PEGetProcA
$LL4@PEGetProcA:

; 161  : 		sz = (LPSTR)(hModule + pdwRVAAddrNames[i]);

  00042	41 8b 12	 mov	 edx, DWORD PTR [r10]
  00045	49 03 d1	 add	 rdx, r9

; 162  : 		dwHash = HashROR13A(sz);

  00048	45 33 c0	 xor	 r8d, r8d
  0004b	eb 0d		 jmp	 SHORT $LN21@PEGetProcA
$LL8@PEGetProcA:
  0004d	0f b6 c0	 movzx	 eax, al
  00050	48 ff c2	 inc	 rdx
  00053	41 c1 c8 0d	 ror	 r8d, 13
  00057	44 03 c0	 add	 r8d, eax
$LN21@PEGetProcA:
  0005a	8a 02		 mov	 al, BYTE PTR [rdx]
  0005c	84 c0		 test	 al, al
  0005e	75 ed		 jne	 SHORT $LL8@PEGetProcA

; 163  : 		if(dwHash == dwProcNameH) {

  00060	44 3b c6	 cmp	 r8d, esi
  00063	74 1c		 je	 SHORT $LN13@PEGetProcA

; 160  : 	for(i = 0; i < exp->NumberOfNames; i++) {

  00065	ff c1		 inc	 ecx
  00067	49 83 c2 04	 add	 r10, 4
  0006b	3b cf		 cmp	 ecx, edi
  0006d	72 d3		 jb	 SHORT $LL4@PEGetProcA
$LN3@PEGetProcA:

; 166  : 		}
; 167  : 	}
; 168  : 	return 0;

  0006f	33 c0		 xor	 eax, eax
$LN1@PEGetProcA:

; 169  : }

  00071	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00076	48 8b 74 24 10	 mov	 rsi, QWORD PTR [rsp+16]
  0007b	48 8b 7c 24 18	 mov	 rdi, QWORD PTR [rsp+24]
  00080	c3		 ret	 0
$LN13@PEGetProcA:

; 164  : 			dwFnIdx = pwNameOrdinals[i];
; 165  : 			return (PVOID)(hModule + pdwRVAAddrFunctions[dwFnIdx]);

  00081	41 0f b7 0c 4b	 movzx	 ecx, WORD PTR [r11+rcx*2]
  00086	8b 04 8b	 mov	 eax, DWORD PTR [rbx+rcx*4]
  00089	49 03 c1	 add	 rax, r9
  0008c	eb e3		 jmp	 SHORT $LN1@PEGetProcA
PEGetProcAddressH ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\killvxk\desktop\ÁÙÊ±\generateshellcode\shellcode\shellcode.c
;	COMDAT HashROR13A
_TEXT	SEGMENT
sz$ = 8
HashROR13A PROC						; COMDAT

; 138  : 	DWORD dwVal, dwHash = 0;

  00000	33 c0		 xor	 eax, eax

; 139  : 	while(*sz) {

  00002	eb 0b		 jmp	 SHORT $LN10@HashROR13A
$LL2@HashROR13A:

; 140  : 		dwVal = (DWORD)*sz++;

  00004	0f b6 d2	 movzx	 edx, dl
  00007	48 ff c1	 inc	 rcx

; 141  : 		dwHash = (dwHash >> 13) | (dwHash << 19);

  0000a	c1 c8 0d	 ror	 eax, 13

; 142  : 		dwHash += dwVal;

  0000d	03 c2		 add	 eax, edx
$LN10@HashROR13A:

; 139  : 	while(*sz) {

  0000f	8a 11		 mov	 dl, BYTE PTR [rcx]
  00011	84 d2		 test	 dl, dl
  00013	75 ef		 jne	 SHORT $LL2@HashROR13A

; 143  : 	}
; 144  : 	return dwHash;
; 145  : }

  00015	c3		 ret	 0
HashROR13A ENDP
_TEXT	ENDS
END
